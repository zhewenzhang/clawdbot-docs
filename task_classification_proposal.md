# 📋 任务分级分类与 Token 优化方案 (V1.0)

## 1. 核心目标
建立一套任务分级机制，针对不同类型的任务动态调整资源（上下文、Token、模型），以达到**效率最大化**和**成本最小化**的平衡。

---

## 2. 任务分类标准 (Taxonomy)

我们将任务分为四大类，依据**复杂度**和**上下文依赖**进行区分：

### A. ⚡️ 快速查询 (Quick Query)
*   **特征**：单一指令，不依赖历史对话，即用即走。
*   **示例**：
    *   "查一下今天天气"
    *   "把这句话翻译成英文"
    *   "提醒我明天早上8点开会"
*   **Token 策略**：**极简模式**。除了必要的 System Prompt，不携带任何历史记录。

### B. 📝 深度分析 (Deep Analysis)
*   **特征**：需要联网搜索、阅读长文、生成报告，产生大量 Token。
*   **示例**：
    *   "分析臻鼎-KY和欣兴的股价走势"
    *   "阅读这份 PDF 并总结要点"
    *   "帮我写一份周报"
*   **Token 策略**：**聚焦模式**。仅携带与该主题相关的上下文（RAG），排除无关闲聊。任务结束后建议生成摘要存档，并释放原始 Token。

### C. 🧠 长期项目 (Long-term Project)
*   **特征**：跨越多个时间段，需要持续记忆，逻辑复杂。
*   **示例**：
    *   "继续优化我们昨天的 Python 脚本"
    *   "帮我规划下个月的旅行行程"
*   **Token 策略**：**项目记忆模式**。建立专属的记忆文件（如 `project_x.md`），每次对话前先读取该文件。

### D. ⚙️ 系统管理 (System Ops)
*   **特征**：涉及配置修改、状态监控、定时任务。
*   **示例**：
    *   "配置 Token 每日报告"
    *   "检查系统负载"
*   **Token 策略**：**精准模式**。需要携带工具定义和配置文件上下文，确保操作准确。

---

## 3. 优化策略矩阵 (Optimization Matrix)

| 任务类型 | 上下文策略 (Context) | 模型选择 (Model) | 预期 Token 消耗 |
| :--- | :--- | :--- | :--- |
| **A. 快速查询** | 🚫 **Zero-Shot** (无历史) | 轻量模型 (如 Flash/Haiku) | 🟢 极低 |
| **B. 深度分析** | 🔍 **Relevant-Only** (仅相关) | 强推理模型 (如 Claude 3.5 Sonnet / Gemini Pro) | 🔴 高 (但通过清理可控) |
| **C. 长期项目** | 📂 **File-Based** (基于文件) | 强推理 + 长窗口模型 | 🟡 中 (依赖摘要) |
| **D. 系统管理** | 🛠 **Tool-Focused** (工具导向) | 强逻辑模型 | 🟡 中 |

---

## 4. 执行路线图 (Execution Plan)

### 第一阶段：手动标记与测试 (当前)
*   在对话中，您可以显式指定任务类型（例如："这是个【深度分析】任务..."）。
*   我会尝试根据您的指令，手动调整我的回复策略（例如：在分析完股票后，主动提议清理上下文）。

### 第二阶段：自动化流程 (Next Step)
*   **自动分类器**：编写一个 Prompt 模板，在接收指令时自动判断属于哪一类。
*   **会话隔离 (Sessions)**：
    *   主会话 (Main) 用于日常闲聊和路由。
    *   检测到 B/C 类任务时，自动 spawn (衍生) 一个子 Agent 去处理，处理完只把结果传回主会话。这样主会话永远保持轻量。

### 第三阶段：记忆优化
*   定期（如每天凌晨）对前一天的 B/C 类任务进行摘要，写入 `MEMORY.md`，然后丢弃原始对话记录。

---

## 5. 给您的建议

为了配合这个优化，您可以在发布复杂任务时：
1.  **明确主题**：例如 "关于[股票分析]，请帮我..."
2.  **任务结束信号**：当一个大任务结束时，可以说 "这个任务结束了"，我会知道该清理缓存了。
